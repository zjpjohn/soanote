======================================================================================================================
        1、注册中心eureka
======================================================================================================================
1、微服务介绍：
    应用拆分成多个服务，服务与服务间通过诸如RESTful API的方式互相调用。
2、演示使用过程：
    2.1：创建注册中心
        通过@EnableEurekaServer注解启动一个服务注册中心
        在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties中问增加如下配置：
            eureka.client.register-with-eureka=false
            eureka.client.fetch-registry=false
    2.2：启动工程后，访问：http://localhost:1111/
    2.3：创建provider：
        假设我们有一个提供计算功能的微服务模块，我们实现一个RESTful API，通过传入两个参数a和b，最后返回a + b的结果。
        2.3.1:在主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现。
        2.3.2:application.properties做一些配置工作，具体如下：
            spring.application.name=compute-service ，在注册中心中指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。
            server.port=2222
            eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ ，指定服务注册中心的位置。
    2.4:启动该工程后，再次访问：http://localhost:1111/ ，可以看到compute-service：2222
3：总结：
    3.1：注册中心中的一个服务可能对应多个不同地址的provider，他们都会发送心跳给注册中心，如果长时间没心跳注册中心就把这个地址的provider下线，但是下线前
        会检查如果下线比例超过了一个阈值，那么认为是网络问题导致的，这样就开启自我保护模式，就不把这个provider对应的地址下线了。
    3.2：默认情况下在丢失85%的节点之后会开启保护模式, 在测试的时候, 由于服务数量比较少, 当有一两个服务下线就会触发阈值, 导致接下来的服务都会被保护, 不会
        下线,测试的时候可以调小这个阈值：
        #自我保护模式默认开启
        #eureka.server.enableSelfPreservation=false
        #阈值设置为20%
        eureka.server.renewalPercentThreshold=0.2
=======================================================================================================
        2、 注册中心eureka--ha
=======================================================================================================
1、注册中心ha：
        进行两两互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server的eureka.client.serviceUrl.defaultZone指向其他的注册中心节点即可实现ha
2：构建双节点的注册中心：
    2.1：创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2
        eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/
    2.2：创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1
        eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/
    2.3：在/etc/hosts文件中添加对peer1和peer2的转换
          127.0.0.1 peer1
          127.0.0.1 peer2
    2.4：通过spring.profiles.active属性来分别启动peer1和peer2
          java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1
          java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2
    2.5：此时访问peer1的注册中心：http://localhost:1111/，如下图所示，我们可以看到registered-replicas中已经有peer2节点的eureka-server了。
        同样地，访问peer2的注册中心：http://localhost:1112/，能看到registered-replicas中已经有peer1节点，并且这些节点在可用分片（available-replicase）之中。
        我们也可以尝试关闭peer1，刷新http://localhost:1112/，可以看到peer1的节点变为了不可用分片（unavailable-replicas）。
3：深入理解注册中心的集群：
    3.1：Eureka Server的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步
    3.2：假设我们有3个注册中心，我们将peer1、peer2、peer3各自都将serviceUrl指向另外两个节点。换言之，peer1、peer2、peer3是两两互相注册的。启动三个服务注册中心，
        并将compute-service的serviceUrl指向peer1并启动，访问http://localhost:1112/，可以看到3个注册中心组成了集群，compute-service服务通过peer1同步给了与之
        互相注册的peer2和peer3。Eureka Server的传播与同步是具备方向性的。
    3.3：两两注册的方式可以实现集群中节点完全对等的效果，实现最高可用性集群，任何一台注册中心故障都不会影响服务的注册与发现
    3.4：Eureka Server具备单方面有指向的服务传播与同步机制，在一些对服务发现有限制的情况下，可以利用这样的机制进行服务注册与发现的的单向控制
4:总结：
    4.1：注册中心集群中每个节点eureka.client.serviceUrl.defaultZone等于其余节点的地址(两两互相注册)，比如1的指向2,3的为
        defaultZone: http://localhost:8762/eureka/,http://localhost:8763/eureka/
    4.2：provider中的eureka.client.serviceUrl.defaultZone=其中任何一个即可，比如为http://discovery:8761/eureka/，这样注册到1后，1会自动同步到其余两个节点
        即provider配置中只需要配置注册中心集群中的一个节点即可。这样即使1挂了，2,3上面开启自我保护还会有provider的，其他consumer还可以访问provider。
5：eureka实现集群的方式：
     5.1：方式1：通过eureka.client.serviceUrl.defaultZone指向其他节点，这样两两相互指向，这些节点构成集群
     5.2：方式2：每个eureka节点单独启动不指向其他，provider启动时候通过eureka.client.serviceUrl.defaultZone指向多个eureka节点，这样就把这些节点做成一个
        ha集群来使用了，这样是由provider决定哪些节点是一个ha的eureka集群，配置麻烦推荐使用第一种方式
6：eureka注册中心集群划分粒度的理解：
    6.1：eureka可以看做是服务的代理，通过eureka来找到服务，所以eureka只需要管理相关的服务即可，比如按照大的业务线来划分每个业务线使用一个eureka集群，这样
        就是浪费一些服务器资源，但是这样每个eureka集群管理的服务进行了分类汇总，管理的数量就比较少(不是一个整个公司一个)，这样的规划2个或节点的eureka集群
        就是高可用的，并且通常是不用增加节点的，即使如果需要增加节点扩容了，provider的配置不用变，只需要修改consumer的配置即可。
7：Zone
    7.1：Eureka支持Region和Zone的概念。其中一个Region可以包含多个Zone。Eureka在启动时需要指定一个Zone名，即当前Eureka属于哪个zone, 如果不指定则属于
        defaultZone。Eureka Client也需要指定Zone, Client(当与Ribbon配置使用时)在向Server获取注册列表时会优先向自己Zone的Eureka发请求，如果自己Zone中的
        Eureka全挂了才会尝试向其它Zone。当获取到远程服务列表后，Client也会优先向同一个Zone的服务发起远程调用。Region和Zone可以对应于现实中的大区和机房，
        如在华北地区有10个机房，在华南地区有20个机房，那么分别为Eureka指定合理的Region和Zone能有效避免跨机房调用，同时一个地区的Eureka坏掉不会导致整个
        该地区的服务都不可用。
===============================================================================================================================
        3、provider
================================================================================================================================
1：provider使用eureka集群的方式：
    1.1：修改application.properties配置文件：
        eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/
        采用的是注册到多个节点上面去，理论上是可以配置注册到一个节点，因为注册中心集群节点之间是互相指向的，他会把注册到他上面的服务同步到另一个节点
    1.2：可以观察到compute-service同时被注册到了peer1和peer2上。若此时断开peer1，由于compute-service同时也向peer2注册，因此在peer2上其他服务依然能访问到
        compute-service，从而实现了高可用的服务注册中心。
    1.3：provider向多个eureka节点同时注册这种方式好，还是provider只向一个eureka1节点注册，通过eureka1同步到eureka2和eureka3这种方式好？？？
    1.4：前者provider给多个eureka节点发心跳，provider压力大点，后者是利用eureka server的 replication，eureka的压力大点
    1.5：如果eureka1挂了，而服务也挂了，那其余eureka节点还是有服务信息的，不需要重新注册的(因为开启了自我保护)
    1.6：所以我建议使用方式1，这样我们provider的配置简单，如果有新节点加入eureka集群时候，这些provider都不用重启，也不需要动态加载配置文件
2、eureka注册中心集群的理解：
    2.1：方式1：通过eureka.client.serviceUrl.defaultZone指向其他节点，这样两两相互指向，这些节点构成集群
    2.2：方式2：每个eureka节点单独启动不指向其他，provider启动时候通过eureka.client.serviceUrl.defaultZone指向多个eureka节点，这样就把这些节点做成一个ha
        集群来使用了，这样是由provider决定哪些节点是一个ha的eureka集群，配置麻烦推荐使用第一种方式
    2.3：eureka可以看做是服务的代理，通过eureka来找到服务，所以eureka只需要管理相关的服务即可，比如按照大的业务线来划分每个业务线使用一个eureka集群，这样
        就是浪费一些服务器资源，但是这样每个eureka集群管理的服务进行了分类汇总，管理的数量就比较少(不是一个整个公司一个)，这样的规划2个或节点的eureka集群
        就是高可用的，并且通常是不用增加节点的，即使如果需要增加节点扩容了，provider的配置不用变，只需要修改consumer的配置即可。
3：provider使用eureka集群的方式：
        3.1：方式1：provider同时向多个eureka节点进行注册：
            eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/
        3.2：方式2：provider只向集群中的一个eureka进行注册：
            因为注册中心集群节点之间是互相指向的，provider直接注册到的eureka，他会把注册到他上面的服务同步到其余的eureka节点上面。
        3.3：provider向多个eureka节点同时注册这种方式好，还是provider只向一个eureka1节点注册，通过eureka1同步到eureka2和eureka3这种方式好？？？
        3.4：前者provider给多个eureka节点发心跳，provider压力大点，后者是利用eureka server的 replication，eureka的压力大点
        3.5：如果eureka1挂了，而服务也挂了，那其余eureka节点还是有服务信息的，不需要重新注册的(因为开启了自我保护)
        3.6：所以我建议使用方式1，这样我们provider的配置简单，如果有新节点加入eureka集群时候，这些provider都不用重启，也不需要动态加载配置文件
===============================================================================================================================
        4、consumer：---ribbon---feign
================================================================================================================================
1、ribbon：
    Ribbon是一个基于HTTP和TCP客户端的负载均衡器。当Ribbon与Eureka联合使用时，它将职责委托给Eureka来确定服务端是否已经启动。使用Ribbon来调用服务，并实现客
        户端的均衡负载。
2、演示使用过程：
    2.1：修改compute-service中的server-port为2223，再启动一个服务提供方：compute-service
    2.2：使用Ribbon实现客户端负载均衡的消费者
        2.2.1：应用主类中，通过@EnableDiscoveryClient注解来添加发现服务能力。创建RestTemplate实例，并通过@LoadBalanced注解开启均衡负载能力。
        2.2.2：创建ConsumerController来消费COMPUTE-SERVICE的add服务。通过直接RestTemplate来调用服务，计算10 + 20的值。
            return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&b=20", String.class).getBody();
    2.3：application.properties中配置eureka服务注册中心
        eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
    2.4：启动该应用，并访问两次：http://localhost:3333/add
        可以看到，之前启动的两个compute-service服务端分别被调用了一次。到这里，我们已经通过Ribbon在客户端已经实现了对服务调用的均衡负载。
3、Feign：
    Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。
    Spring Cloud为Feign增加了对Spring MVC注解的支持，还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。
3.1：Feign如何方便的声明对上述computer-service服务的定义和调用。
    3.1.1：创建一个Spring Boot工程，配置pom.xml，将上述的配置中的ribbon依赖替换成feign的依赖
    3.1.2：在应用主类中通过@EnableFeignClients注解开启Feign功能
    3.1.3：定义compute-service服务的接口
        使用@FeignClient("compute-service")注解来绑定该接口对应compute-service服务
        接口方法上面的@RequestMapping("/{id}")，对应服务方法上面的@GetMapping("/{id}")，两边的名称可以随便
    3.1.4：通过Spring MVC的注解来配置compute-service服务下的具体实现
        在web层中调用上面定义的ComputeClient
    3.1.5：application.properties中不用变，指定eureka服务注册中心即可
    3.1.6：启动该应用，访问几次：http://localhost:3333/add ，对服务提供方实现了均衡负载。
    3.1.7：这一节我们通过Feign以接口和注解配置的方式，轻松实现了对compute-service服务的绑定，这样我们就可以在本地应用中像本地服务一下的调用它，并且做到了
        客户端均衡负载。
4总结：
    4.1：ribbon和feign方式，都可以从eureka找到某个服务，可能对应多个provider地址列表进行软负载选择一个进行访问
    4.2：ribbon是通过restTemplate调用
    4.3：feigin是通过定义一个接口，接口中的方法参数跟服务中方法的参数相同就可以，这个接口利用@FeignClient即获得了直接访问服务的能力。
====================================================================================================
        5、hystrix---熔断器
====================================================================================================
 1、为何使用断路器：
    cousumer从注册中心获得多个provider的地址列表，在访问这些请求时候，如果失败率达到一个阈值后，就自动开启断路器模式，consumer就不会调用provider了，直接返回
        一个指定的信息。
    在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就会因依赖关系形成故障蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构就更加的不稳定。为
        了解决这样的问题，因此产生了断路器模式。在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一
        个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。在Spring Cloud中使用了Hystrix 来
        实现断路器的功能。
    断路器有三个状态 关闭 半开 打开，正常情况下 断路器是关闭状态，当失败率达到一定的程度 断路器就打开 这个时候压根不再去请求远程了，从而防止了系统的级联错误。
2、ribbon中使用熔断器：
    2.1：Ribbon中引入Hystrix，pom.xml中引入依赖hystrix依赖
    2.2:主类中使用@EnableCircuitBreaker注解开启断路器功能
    2.3:：使用ribbon消费服务的函数上增加@HystrixCommand注解来指定回调方法
          @HystrixCommand(fallbackMethod = "addServiceFallback")
           public String addService() {
           return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&b=20", String.class).getBody();
          }
3、feign中使用断路器：
    3.1：使用@FeignClient注解中的fallback属性指定回调类
        @FeignClient(value = "compute-service", fallback = ComputeClientHystrix.class)
        public interface ComputeClient {
            @RequestMapping(method = RequestMethod.GET, value = "/add")
            Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);
        }
    3.2：创建回调类ComputeClientHystrix，实现@FeignClient的接口，此时实现的方法就是对应@FeignClient接口中映射的fallback函数。
        @Component
        public class ComputeClientHystrix implements ComputeClient {
            @Override
            public Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b) {
                return -9999;
            }
        }
    3.3：再用之前的方法验证一下，是否在compute-service服务不可用的情况下，页面返回了-9999。
4：总结；
    4.1：熔断器本质是方法级别的，consumer在调用某个方法时候大量出错就对这个方法进行熔断，执行一个设定的方法，ribbon是一个方法一个方法进行指定，feign是
        指定一个类来实现接口，接口中的每个方法熔断时候就执行这个类中的实现的方法。







